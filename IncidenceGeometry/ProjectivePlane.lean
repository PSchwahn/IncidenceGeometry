import IncidenceGeometry.Defs

open IncidenceGeometry
namespace ProjectivePlane

variable (P L : Type*) [instPlane : ProjectivePlane P L]

theorem nondeg : ‚àÉ p : Fin 4 ‚Üí P, Function.Injective p ‚àß
    ‚àÄ (l : L) (i : Fin 4), ¬¨(p i ùêà l ‚àß p (i + 1) ùêà l ‚àß p (i + 2) ùêà l) :=
  ProjectivePlane.nondeg'

theorem dual_nondeg : ‚àÉ l : Fin 4 ‚Üí L, Function.Injective l ‚àß
    ‚àÄ (p : P) (i : Fin 4), ¬¨(p ùêà l i ‚àß p ùêà l (i + 1) ‚àß p ùêà l (i + 2)) := by
  obtain ‚ü®p, pinj, h‚ü© := nondeg P L
  let l‚ÇÄ‚ÇÅ := instPlane.join (p 0) (p 1)
  let l‚ÇÄ‚ÇÇ := instPlane.join (p 0) (p 2)
  let l‚ÇÅ‚ÇÉ := instPlane.join (p 1) (p 3)
  let l‚ÇÇ‚ÇÉ := instPlane.join (p 2) (p 3)
  let l := ![l‚ÇÄ‚ÇÅ, l‚ÇÄ‚ÇÇ, l‚ÇÅ‚ÇÉ, l‚ÇÇ‚ÇÉ]
  have linj : Function.Injective l := by
    intro i j hij
    --can we golf this? or is this doomed because the definition of l is not so nice?
    fin_cases i <;> fin_cases j <;> dsimp at *
    ¬∑ exfalso
      apply h (l 0) 0
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
      rw [hij]
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
    ¬∑ exfalso
      apply h (l 0) 3
      rw [hij]
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).right
      rw [‚Üêhij]
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
    ¬∑ exfalso
      apply h (l 0) 0
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
      rw [hij]
      use (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).left
    ¬∑ exfalso
      apply h (l 0) 0
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
      rw [‚Üêhij]
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
    ¬∑ exfalso
      apply h (l 1) 0
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).left
      symm
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
      rw [hij]
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).left
    ¬∑ exfalso
      apply h (l 1) 2
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
      rw [hij]
      use (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).right
      rw [‚Üêhij]
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).left
    ¬∑ exfalso
      apply h (l 0) 3
      rw [‚Üêhij]
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).right
      rw [hij]
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
    ¬∑ exfalso
      apply h (l 1) 0
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).left
      symm
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
      rw [‚Üêhij]
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).left
    ¬∑ exfalso
      apply h (l 2) 1
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).left
      symm
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).right
      rw [hij]
      use (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).left
    ¬∑ exfalso
      apply h (l 0) 0
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      use (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
      rw [‚Üêhij]
      use (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).left
    ¬∑ exfalso
      apply h (l 1) 2
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
      rw [‚Üêhij]
      use (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).right
      rw [hij]
      use (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).left
    ¬∑ exfalso
      apply h (l 2) 1
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).left
      symm
      use (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).right
      rw [‚Üêhij]
      use (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).left
  use l, linj
  --show that no point lies on any three of the four lines
  intro q i
  fin_cases i <;> dsimp
  ¬∑ intro ‚ü®hq‚ÇÄ, hq‚ÇÅ, hq‚ÇÇ‚ü©
    --show q = p 0 = p 1
    have hq' := instPlane.unique_meet (l 0) (l 1) q (Function.Injective.ne linj (by decide)) hq‚ÇÄ hq‚ÇÅ
    have hq'' := instPlane.unique_meet (l 0) (l 2) q (Function.Injective.ne linj (by decide)) hq‚ÇÄ hq‚ÇÇ
    have hp‚ÇÄ := instPlane.unique_meet (l 0) (l 1) (p 0) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).left
    have hp‚ÇÅ := instPlane.unique_meet (l 0) (l 2) (p 1) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
      (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).left
    have : p 0 = p 1 := by
      rw [hp‚ÇÄ, hp‚ÇÅ, ‚Üêhq', ‚Üêhq'']
    apply pinj at this
    simp at this
  ¬∑ intro ‚ü®hq‚ÇÅ, hq‚ÇÇ, hq‚ÇÉ‚ü©
    --show q = p 2 = p 3
    have hq' := instPlane.unique_meet (l 1) (l 3) q (Function.Injective.ne linj (by decide)) hq‚ÇÅ hq‚ÇÉ
    have hq'' := instPlane.unique_meet (l 2) (l 3) q (Function.Injective.ne linj (by decide)) hq‚ÇÇ hq‚ÇÉ
    have hp‚ÇÇ := instPlane.unique_meet (l 1) (l 3) (p 2) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
      (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).left
    have hp‚ÇÉ := instPlane.unique_meet (l 2) (l 3) (p 3) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).right
      (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).right
    have : p 2 = p 3 := by
      rw [hp‚ÇÇ, hp‚ÇÉ, ‚Üêhq', ‚Üêhq'']
    apply pinj at this
    simp at this
  ¬∑ intro ‚ü®hq‚ÇÇ, hq‚ÇÉ, hq‚ÇÄ‚ü©
    --show q = p 1 = p 3
    have hq' := instPlane.unique_meet (l 0) (l 2) q (Function.Injective.ne linj (by decide)) hq‚ÇÄ hq‚ÇÇ
    have hq'' := instPlane.unique_meet (l 2) (l 3) q (Function.Injective.ne linj (by decide)) hq‚ÇÇ hq‚ÇÉ
    have hp‚ÇÅ := instPlane.unique_meet (l 0) (l 2) (p 1) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).right
      (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).left
    have hp‚ÇÉ := instPlane.unique_meet (l 2) (l 3) (p 3) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 1) (p 3) (Function.Injective.ne pinj (by decide))).right
      (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).right
    have : p 1 = p 3 := by
      rw [hp‚ÇÅ, hp‚ÇÉ, ‚Üêhq', ‚Üêhq'']
    apply pinj at this
    simp at this
  ¬∑ intro ‚ü®hq‚ÇÉ, hq‚ÇÄ, hq‚ÇÅ‚ü©
    --show q = p 0 = p 2
    have hq' := instPlane.unique_meet (l 0) (l 1) q (Function.Injective.ne linj (by decide)) hq‚ÇÄ hq‚ÇÅ
    have hq'' := instPlane.unique_meet (l 1) (l 3) q (Function.Injective.ne linj (by decide)) hq‚ÇÅ hq‚ÇÉ
    have hp‚ÇÄ := instPlane.unique_meet (l 0) (l 1) (p 0) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 0) (p 1) (Function.Injective.ne pinj (by decide))).left
      (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).left
    have hp‚ÇÇ := instPlane.unique_meet (l 1) (l 3) (p 2) (Function.Injective.ne linj (by decide))
      (instPlane.join_incident (p 0) (p 2) (Function.Injective.ne pinj (by decide))).right
      (instPlane.join_incident (p 2) (p 3) (Function.Injective.ne pinj (by decide))).left
    have : p 0 = p 2 := by
      rw [hp‚ÇÄ, hp‚ÇÇ, ‚Üêhq', ‚Üêhq'']
    apply pinj at this
    simp at this

theorem dual_nondeg' : ‚àÉ l : Fin 4 ‚Üí L, Function.Injective l ‚àß
    ‚àÄ (p : P) (i : Fin 4), ¬¨(p ùêà l i ‚àß p ùêà l (i + 1) ‚àß p ùêà l (i + 2)) := by
  obtain ‚ü®p, pinj, h‚ü© := nondeg P L
  let l : Fin 4 ‚Üí L := fun i ‚Ü¶ join (p i) (p (i + 1))
  have l‚ÇÄleft := fun i ‚Ü¶ (instPlane.join_incident (p i) (p (i + 1)) (Function.Injective.ne pinj (by simp))).left
  have l‚ÇÄright := fun i ‚Ü¶ (instPlane.join_incident (p i) (p (i + 1)) (Function.Injective.ne pinj (by simp))).right
  have l‚ÇÅleft := fun i ‚Ü¶ (instPlane.join_incident (p (i + 1)) (p (i + 2)) (Function.Injective.ne pinj (by simp))).left
  have aux‚ÇÅ (i) : l (i + 1) = join (p (i + 1)) (p (i + 2)) := by
    unfold l
    rw [add_assoc]
    rfl
  simp_rw [‚Üêaux‚ÇÅ] at l‚ÇÅleft
  have l‚ÇÅright := fun i ‚Ü¶ (instPlane.join_incident (p (i + 1)) (p (i + 2)) (Function.Injective.ne pinj (by simp))).right
  simp_rw [‚Üêaux‚ÇÅ] at l‚ÇÅright
  have l‚ÇÇleft := fun i ‚Ü¶ (instPlane.join_incident (p (i + 2)) (p (i + 3)) (Function.Injective.ne pinj (by simp))).left
  have aux‚ÇÇ (i) : l (i + 2) = join (p (i + 2)) (p (i + 3)) := by
    unfold l
    rw [add_assoc]
    rfl
  simp_rw [‚Üêaux‚ÇÇ] at l‚ÇÇleft
  have l‚ÇÉleft := fun i ‚Ü¶ (instPlane.join_incident (p (i + 3)) (p i) (Function.Injective.ne pinj (by simp))).left
  have aux‚ÇÉ (i) : l (i + 3) = join (p (i + 3)) (p i) := by
    unfold l
    rw [add_assoc]
    simp
  simp_rw [‚Üêaux‚ÇÉ] at l‚ÇÉleft
  have linj : Function.Injective l := by
    have diff : ‚àÄ (i j : Fin 4), j = i ‚à® j = i + 1 ‚à® j = i + 2 ‚à® j = i + 3 := by decide
    intro i j hij
    rcases diff i j with h‚ÇÄ | h‚ÇÅ | h‚ÇÇ | h‚ÇÉ
    ¬∑ exact h‚ÇÄ.symm
    ¬∑ exfalso
      rw [h‚ÇÅ] at hij
      --p i, p (i + 1) and p (i + 2) lie on the same line
      apply h (l i) i
      use l‚ÇÄleft i, l‚ÇÄright i
      rw [hij]
      use l‚ÇÅright i
    ¬∑ exfalso
      rw [h‚ÇÇ] at hij
      --p i, p (i + 1), p (i + 2) and p (i + 3) lie on the same line
      apply h (l i) i
      use l‚ÇÄleft i, l‚ÇÄright i
      rw [hij]
      use l‚ÇÇleft i
    ¬∑ exfalso
      rw [h‚ÇÉ] at hij
      --p i, p (i + 1), p (i + 3) lie on the same line
      apply h (l i) (i + 3)
      rw [hij]
      use l‚ÇÉleft i
      rw [‚Üêhij, add_assoc, add_assoc]
      simp only [Fin.reduceAdd, add_zero]
      use l‚ÇÄleft i, l‚ÇÄright i
  use l, linj
  intro q i ‚ü®h‚ÇÄ, h‚ÇÅ, h‚ÇÇ‚ü©
  have hq := instPlane.unique_meet (l i) (l (i + 1)) q (Function.Injective.ne linj (by simp)) h‚ÇÄ h‚ÇÅ
  have hq' := instPlane.unique_meet (l (i + 1)) (l (i + 2)) q (Function.Injective.ne linj (by simp)) h‚ÇÅ h‚ÇÇ
  have hp‚ÇÅ := instPlane.unique_meet (l i) (l (i + 1)) (p (i + 1)) (Function.Injective.ne linj (by simp))
    (l‚ÇÄright i) (l‚ÇÅleft i)
  have hp‚ÇÇ := instPlane.unique_meet (l (i + 1)) (l (i + 2)) (p (i + 2)) (Function.Injective.ne linj (by simp))
    (l‚ÇÅright i) (l‚ÇÇleft i)
  have : p (i + 1) = p (i + 2) := by
    rw [hp‚ÇÅ, hp‚ÇÇ, ‚Üêhq, ‚Üêhq']
  apply pinj at this
  simp at this

instance Dual : ProjectivePlane L P where
  Incident := fun l p => p ùêà l
  join := instPlane.meet
  join_incident := instPlane.meet_incident
  unique_join := instPlane.unique_meet
  meet := instPlane.join
  meet_incident := instPlane.join_incident
  unique_meet := instPlane.unique_join
  nondeg' := dual_nondeg P L

--is this formulation correct? where do we have to assume inequality?
def IsDesarguesian : Prop :=
  ‚àÄ (p p' : Fin 3 ‚Üí P) (ne : (i : Fin 3) ‚Üí  p i ‚â† p' i)
    (ne' : (i : Fin 3) ‚Üí (join (p i) (p (i + 1)) : L) ‚â† (join (p' i) (p' (i + 1)) : L))
    (o : P) (central : (i : Fin 3) ‚Üí o ùêà (join (p i) (p' i) : L)),
  ‚àÉ l : L, ‚àÄ i : Fin 3, (meet (join (p i) (p (i + 1)) : L) (join (p' i) (p' (i + 1)) : L) : P) ùêà l

theorem dual_desarguesian (h : IsDesarguesian P L) : IsDesarguesian L P := by
  unfold IsDesarguesian at *
  intro l l' ne ne' m central
  let p : Fin 3 ‚Üí P := fun i ‚Ü¶ meet (l i) (l (i + 1))
  let p' : Fin 3 ‚Üí P := fun i ‚Ü¶ meet (l' i) (l' (i + 1))
  have ne'' : ‚àÄ i : Fin 3, join (p i) (p (i + 1)) ‚â† (join (p' i) (p' (i + 1)) : L) := by
    sorry
  specialize h p p' ne' ne''
  sorry

theorem desarguesian_iff_dual : IsDesarguesian P L ‚Üî IsDesarguesian L P :=
  ‚ü®dual_desarguesian P L, dual_desarguesian L P‚ü©

end ProjectivePlane
